# 4.30 go垃圾回收机制

现版本的垃圾回收是使用三色标记法、写屏障和辅助gc完成。

## GC流程

1. Mark: 包含两部分:

- Mark Prepare: 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等。**这个过程需要STW**
- GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。**该过程后台并行执行**

2. Mark Termination: 完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下。**这个过程也是会STW的。**

3. Sweep: 按照标记结果回收所有的白色对象，**该过程后台并行执行**

4. Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。




## 三色标记法

三色标记法是对标记阶段的改进，原理如下：

1. 初始状态所有对象都是白色。
2. 从root根出发扫描所有根对象，将他们引用的对象标记为灰色
3. 分析灰色对象是否引用了其他对象。如果没有引用其它对象则将该灰色对象标记为黑色；如果有引用则将它变为黑色的同时将它引用的对象也变为灰色
4. 重复步骤3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。

## 写屏障

根据我的理解这应该不是阻止写操作，而是将写操作改变之后的对象标记灰色防止丢失，然后再后面的gc中再次扫描。

## 辅助GC

当用户分配空间的速度过快，就会造成go停止用户逻辑而STW的进行垃圾回收。