# Go内存分配

在c语言中，如果你不显式的使用动态分配内存，那么你所初始化的变量都会分配在栈上，而你使用new/malloc等就会分配到堆中，这没有例外，但如果你在go语言中，事情好像就没有那么简单了。

go 没有像 C 语言那样提供精确的堆与栈分配控制，由于提供了内存自动管理的功能，很大程度上**模糊了堆与栈的界限**。例如以下代码：

~~~go
package main

func main() {
    str := GetString()
    _ = str
}

func GetString() *string {
    var s string
    s = "hello"
    return &s
}
~~~

在GetString函数中s是一个局部变量，在c中应该被分配在栈中，然后返回s的地址，在main中打印可能会报空指针异常或者奇怪的字符或者0，但在go中却能正常输出。

行 10 中的变量 `s = "hello"` 尽管声明在了 `GetString()` 函数内，但是在 `main` 函数中却仍然能够访问到返回的变量；这种在函数内定义的局部变量，能够突破自身的范围被外部访问的行为称作逃逸，也即通过逃逸将变量分配到堆上，能够跨边界进行数据共享。

在go语言中，也许你定义的是一个局部变量，但是如果编译器检测到这个局部变量可能会被外部访问，就会将这恶鬼变量分配在堆上。也或许你new出来的对象，由于不会被外部调用，只在这个函数中起作用，编译器会把这个变量分配在栈中。

## 内存逃逸好处

### java

1. 栈上分配

对象都是在堆上分配的，而垃圾回收机制会回收堆中不再使用的对象，但是筛选可回收对象，回收对象还有整理内存都需要消耗时间。如果能够通过逃逸分析确定某些对象不会逃出方法之外，那就可以让这个对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。

在一般应用中，如果不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了。

2. 同步消除

线程同步本身比较耗时，如果确定一个变量不会逃逸出线程，无法被其它线程访问到，那这个变量的读写就不会存在竞争，对这个变量的同步措施可以清除。

3. 标量替换

Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。

go语言应该类似